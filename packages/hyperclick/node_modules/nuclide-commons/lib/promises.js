
/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { var callNext = step.bind(null, 'next'); var callThrow = step.bind(null, 'throw'); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(callNext, callThrow); } } callNext(); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

/**
 * Allows a caller to ensure that the results it receives from consecutive
 * promise resolutions are never outdated. Usage:
 *
 * var requestSerializer = new RequestSerializer();
 *
 * // in some later loop:
 *
 * // note that you do not await the async function here -- you must pass the
 * // promise it returns to `run`
 * var result = await requestSerializer.run(someAsyncFunction())
 *
 * if (result.status === 'success') {
 *   ....
 *   result.result
 * } else if (result.status === 'outdated') {
 *   ....
 * }
 *
 * The contract is that the status is 'success' if and only if this was the most
 * recently dispatched call of 'run'. For example, if you call run(promise1) and
 * then run(promise2), and promise2 resolves first, the second callsite would
 * receive a 'success' status. If promise1 later resolved, the first callsite
 * would receive an 'outdated' status.
 */

var RequestSerializer = (function () {
  function RequestSerializer() {
    _classCallCheck(this, RequestSerializer);

    this._lastDispatchedOp = 0;
    this._lastFinishedOp = 0;
  }

  _createClass(RequestSerializer, [{
    key: 'run',
    value: _asyncToGenerator(function* (promise) {
      var thisOp = this._lastDispatchedOp + 1;
      this._lastDispatchedOp = thisOp;
      var result = yield promise;
      if (this._lastFinishedOp < thisOp) {
        this._lastFinishedOp = thisOp;
        return {
          status: 'success',
          result: result
        };
      } else {
        return {
          status: 'outdated'
        };
      }
    })
  }, {
    key: 'isRunInProgress',
    value: function isRunInProgress() {
      return this._lastDispatchedOp > this._lastFinishedOp;
    }
  }]);

  return RequestSerializer;
})();

var promises = module.exports = {

  /**
   * Returns a value derived asynchronously from an element in the items array.
   * The test function is applied sequentially to each element in items until
   * one returns a Promise that resolves to a non-null value. When this happens,
   * the Promise returned by this method will resolve to that non-null value. If
   * no such Promise is produced, then the Promise returned by this function
   * will resolve to null.
   *
   * @param items Array of elements that will be passed to test, one at a time.
   * @param test Will be called with each item and must return either:
   *     (1) A "thenable" (i.e, a Promise or promise-like object) that resolves
   *         to a derived value (that will be returned) or null.
   *     (2) null.
   *     In both cases where null is returned, test will be applied to the next
   *     item in the array.
   * @param thisArg Receiver that will be used when test is called.
   * @return Promise that resolves to an asynchronously derived value or null.
   */
  asyncFind: function asyncFind(items, test, thisArg) {
    return new Promise(function (resolve, reject) {
      // Create a local copy of items to defend against the caller modifying the
      // array before this Promise is resolved.
      items = items.slice();
      var numItems = items.length;

      var next = _asyncToGenerator(function* (index) {
        if (index === numItems) {
          resolve(null);
          return;
        }

        var item = items[index];
        var result = yield test.call(thisArg, item);
        if (result !== null) {
          resolve(result);
        } else {
          next(index + 1);
        }
      });

      next(0);
    });
  },

  denodeify: function denodeify(f) {
    return function () {
      var _this = this;

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return new Promise(function (resolve, reject) {
        function callback(error, result) {
          if (error) {
            reject(error);
          } else {
            resolve(result);
          }
        }
        f.apply(_this, args.concat([callback]));
      });
    };
  },

  /**
   * A Promise utility that runs a maximum of limit async operations at a time iterating over an array
   * and returning the result of executions.
   * e.g. to limit the number of file reads to 5,
   * replace the code:
   *    var fileContents = await Promise.all(filePaths.map(fsPromise.readFile))
   * with:
   *    var fileContents = await asyncLimit(filePaths, 5, fsPromise.readFile)
   *
   * This is particulrily useful to limit IO operations to a configurable maximum (to avoid blocking),
   * while enjoying the configured level of parallelism.
   *
   * @param array the array of items for iteration.
   * @param limit the configurable number of parallel async operations.
   * @param mappingFunction the async Promise function that could return a useful result.
   */
  asyncLimit: function asyncLimit(array, limit, mappingFunction) {
    var result = new Array(array.length);
    var parallelPromises = 0;
    var index = 0;

    var parallelLimit = Math.min(limit, array.length);

    return new Promise(function (resolve, reject) {
      var runPromise = _asyncToGenerator(function* () {
        if (index === array.length) {
          if (parallelPromises === 0) {
            resolve(result);
          }
          return;
        }
        ++parallelPromises;
        var i = index++;
        try {
          result[i] = yield mappingFunction(array[i]);
        } catch (e) {
          reject(e);
        }
        --parallelPromises;
        runPromise();
      });

      while (parallelPromises < parallelLimit) {
        runPromise();
      }
    });
  },

  /**
   * `filter` Promise utility that allows filtering an array with an async Promise function.
   * It's an alternative to `Array.prototype.filter` that accepts an async function.
   * You can optionally configure a limit to set the maximum number of async operations at a time.
   *
   * Previously, with the `Promise.all` primitive, we can't set the parallelism limit and we have to
   * `filter`, so, we replace the old `filter` code:
   *     var existingFilePaths = [];
   *     await Promise.all(filePaths.map(async (filePath) => {
   *       if (await fsPromise.exists(filePath)) {
   *         existingFilePaths.push(filePath);
   *       }
   *     }));
   * with limit 5 parallel filesystem operations at a time:
   *    var existingFilePaths = await asyncFilter(filePaths, fsPromise.exists, 5);
   *
   * @param array the array of items for `filter`ing.
   * @param filterFunction the async `filter` function that returns a Promise that resolves to a boolean.
   * @param limit the configurable number of parallel async operations.
   */
  asyncFilter: _asyncToGenerator(function* (array, filterFunction, limit) {
    var filteredList = [];
    yield promises.asyncLimit(array, limit || array.length, _asyncToGenerator(function* (item) {
      if (yield filterFunction(item)) {
        filteredList.push(item);
      }
    }));
    return filteredList;
  }),

  /**
   * `some` Promise utility that allows `some` an array with an async Promise some function.
   * It's an alternative to `Array.prototype.some` that accepts an async some function.
   * You can optionally configure a limit to set the maximum number of async operations at a time.
   *
   * Previously, with the Promise.all primitive, we can't set the parallelism limit and we have to
   * `some`, so, we replace the old `some` code:
   *     var someFileExist = false;
   *     await Promise.all(filePaths.map(async (filePath) => {
   *       if (await fsPromise.exists(filePath)) {
   *         someFileExist = true;
   *       }
   *     }));
   * with limit 5 parallel filesystem operations at a time:
   *    var someFileExist = await asyncSome(filePaths, fsPromise.exists, 5);
   *
   * @param array the array of items for `some`ing.
   * @param someFunction the async `some` function that returns a Promise that resolves to a boolean.
   * @param limit the configurable number of parallel async operations.
   */
  asyncSome: _asyncToGenerator(function* (array, someFunction, limit) {
    var resolved = false;
    yield promises.asyncLimit(array, limit || array.length, _asyncToGenerator(function* (item) {
      if (resolved) {
        // We don't need to call the someFunction anymore or wait any longer.
        return;
      }
      if (yield someFunction(item)) {
        resolved = true;
      }
    }));
    return resolved;
  }),

  /*
   * Returns a promise that will resolve after `milliSeconds` milli seconds.
   * this can be used to pause execution asynchronously.
   * e.g. await awaitMilliSeconds(1000), pauses the async flow execution for 1 second.
   */
  awaitMilliSeconds: function awaitMilliSeconds(milliSeconds) {
    return new Promise(function (resolve, reject) {
      setTimeout(resolve, milliSeconds);
    });
  },

  RequestSerializer: RequestSerializer
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy93MS9fMm1jNm0wNTBxbjIzMm5wc2Y5ejNoZnNoNThfamgvVC90bXBpMzV6akdwdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLWNvbW1vbnMvbGliL3Byb21pc2VzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFdBQVcsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBMkNOLGlCQUFpQjtBQUlWLFdBSlAsaUJBQWlCLEdBSVA7MEJBSlYsaUJBQWlCOztBQUtuQixRQUFJLENBQUMsaUJBQWlCLEdBQUcsQ0FBQyxDQUFDO0FBQzNCLFFBQUksQ0FBQyxlQUFlLEdBQUcsQ0FBQyxDQUFDO0dBQzFCOztlQVBHLGlCQUFpQjs7NkJBU1QsV0FBQyxPQUFtQixFQUF5QjtBQUN2RCxVQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsaUJBQWlCLEdBQUcsQ0FBQyxDQUFDO0FBQ3hDLFVBQUksQ0FBQyxpQkFBaUIsR0FBRyxNQUFNLENBQUM7QUFDaEMsVUFBSSxNQUFNLEdBQUcsTUFBTSxPQUFPLENBQUM7QUFDM0IsVUFBSSxJQUFJLENBQUMsZUFBZSxHQUFHLE1BQU0sRUFBRTtBQUNqQyxZQUFJLENBQUMsZUFBZSxHQUFHLE1BQU0sQ0FBQztBQUM5QixlQUFPO0FBQ0wsZ0JBQU0sRUFBRSxTQUFTO0FBQ2pCLGdCQUFNLEVBQU4sTUFBTTtTQUNQLENBQUM7T0FDSCxNQUFNO0FBQ0wsZUFBTztBQUNMLGdCQUFNLEVBQUUsVUFBVTtTQUNuQixDQUFDO09BQ0g7S0FDRjs7O1dBRWMsMkJBQVk7QUFDekIsYUFBTyxJQUFJLENBQUMsaUJBQWlCLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQztLQUN0RDs7O1NBNUJHLGlCQUFpQjs7O0FBK0J2QixJQUFJLFFBQVEsR0FBRyxNQUFNLENBQUMsT0FBTyxHQUFHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9COUIsV0FBUyxFQUFNLG1CQUFDLEtBQWUsRUFBRSxJQUEyQixFQUFFLE9BQWUsRUFBZTtBQUMxRixXQUFPLElBQUksT0FBTyxDQUFDLFVBQUMsT0FBTyxFQUFFLE1BQU0sRUFBSzs7O0FBR3RDLFdBQUssR0FBRyxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUM7QUFDdEIsVUFBSSxRQUFRLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQzs7QUFFNUIsVUFBSSxJQUFJLHFCQUFHLFdBQWUsS0FBSyxFQUFFO0FBQy9CLFlBQUksS0FBSyxLQUFLLFFBQVEsRUFBRTtBQUN0QixpQkFBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2QsaUJBQU87U0FDUjs7QUFFRCxZQUFJLElBQUksR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDeEIsWUFBSSxNQUFNLEdBQUcsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztBQUM1QyxZQUFJLE1BQU0sS0FBSyxJQUFJLEVBQUU7QUFDbkIsaUJBQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUNqQixNQUFNO0FBQ0wsY0FBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQztTQUNqQjtPQUNGLENBQUEsQ0FBQzs7QUFFRixVQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDVCxDQUFDLENBQUM7R0FDSjs7QUFFRCxXQUFTLEVBQUEsbUJBQUMsQ0FBK0IsRUFBeUM7QUFDaEYsV0FBTyxZQUE4Qjs7O3dDQUFsQixJQUFJO0FBQUosWUFBSTs7O0FBQ3JCLGFBQU8sSUFBSSxPQUFPLENBQUMsVUFBQyxPQUFPLEVBQUUsTUFBTSxFQUFLO0FBQ3RDLGlCQUFTLFFBQVEsQ0FBQyxLQUFLLEVBQUUsTUFBTSxFQUFFO0FBQy9CLGNBQUksS0FBSyxFQUFFO0FBQ1Qsa0JBQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztXQUNmLE1BQU07QUFDTCxtQkFBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1dBQ2pCO1NBQ0Y7QUFDRCxTQUFDLENBQUMsS0FBSyxRQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7T0FDeEMsQ0FBQyxDQUFDO0tBQ0osQ0FBQztHQUNIOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkQsWUFBVSxFQUFNLG9CQUFDLEtBQWUsRUFBRSxLQUFhLEVBQUUsZUFBd0MsRUFBcUI7QUFDNUcsUUFBSSxNQUFnQixHQUFHLElBQUksS0FBSyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUMvQyxRQUFJLGdCQUFnQixHQUFHLENBQUMsQ0FBQztBQUN6QixRQUFJLEtBQUssR0FBRyxDQUFDLENBQUM7O0FBRWQsUUFBSSxhQUFhLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDOztBQUVsRCxXQUFPLElBQUksT0FBTyxDQUFDLFVBQUMsT0FBTyxFQUFFLE1BQU0sRUFBSztBQUN0QyxVQUFJLFVBQVUscUJBQUcsYUFBWTtBQUMzQixZQUFJLEtBQUssS0FBSyxLQUFLLENBQUMsTUFBTSxFQUFFO0FBQzFCLGNBQUksZ0JBQWdCLEtBQUssQ0FBQyxFQUFFO0FBQzFCLG1CQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7V0FDakI7QUFDRCxpQkFBTztTQUNSO0FBQ0QsVUFBRSxnQkFBZ0IsQ0FBQztBQUNuQixZQUFJLENBQUMsR0FBRyxLQUFLLEVBQUUsQ0FBQztBQUNoQixZQUFJO0FBQ0YsZ0JBQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxNQUFNLGVBQWUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUM3QyxDQUFDLE9BQU8sQ0FBQyxFQUFFO0FBQ1YsZ0JBQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNYO0FBQ0QsVUFBRSxnQkFBZ0IsQ0FBQztBQUNuQixrQkFBVSxFQUFFLENBQUM7T0FDZCxDQUFBLENBQUM7O0FBRUYsYUFBTyxnQkFBZ0IsR0FBRyxhQUFhLEVBQUU7QUFDdkMsa0JBQVUsRUFBRSxDQUFDO09BQ2Q7S0FDRixDQUFDLENBQUM7R0FDSjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNCRCxBQUFNLGFBQVcsb0JBQUcsV0FBQyxLQUFlLEVBQUUsY0FBNkMsRUFBRSxLQUFjLEVBQXFCO0FBQ3RILFFBQUksWUFBWSxHQUFHLEVBQUUsQ0FBQztBQUN0QixVQUFNLFFBQVEsQ0FBQyxVQUFVLENBQUMsS0FBSyxFQUFFLEtBQUssSUFBSSxLQUFLLENBQUMsTUFBTSxvQkFBRSxXQUFPLElBQUksRUFBUTtBQUN6RSxVQUFJLE1BQU0sY0FBYyxDQUFDLElBQUksQ0FBQyxFQUFFO0FBQzlCLG9CQUFZLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO09BQ3pCO0tBQ0YsRUFBQyxDQUFDO0FBQ0gsV0FBTyxZQUFZLENBQUM7R0FDckIsQ0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNCRCxBQUFNLFdBQVMsb0JBQUcsV0FBQyxLQUFlLEVBQUUsWUFBMkMsRUFBRSxLQUFjLEVBQW9CO0FBQ2pILFFBQUksUUFBUSxHQUFHLEtBQUssQ0FBQztBQUNyQixVQUFNLFFBQVEsQ0FBQyxVQUFVLENBQUMsS0FBSyxFQUFFLEtBQUssSUFBSSxLQUFLLENBQUMsTUFBTSxvQkFBRSxXQUFPLElBQUksRUFBUTtBQUN6RSxVQUFJLFFBQVEsRUFBRTs7QUFFWixlQUFPO09BQ1I7QUFDRCxVQUFJLE1BQU0sWUFBWSxDQUFDLElBQUksQ0FBQyxFQUFFO0FBQzVCLGdCQUFRLEdBQUcsSUFBSSxDQUFDO09BQ2pCO0tBQ0YsRUFBQyxDQUFDO0FBQ0gsV0FBTyxRQUFRLENBQUM7R0FDakIsQ0FBQTs7Ozs7OztBQU9ELG1CQUFpQixFQUFBLDJCQUFDLFlBQW9CLEVBQVc7QUFDL0MsV0FBTyxJQUFJLE9BQU8sQ0FBQyxVQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUs7QUFDdEMsZ0JBQVUsQ0FBQyxPQUFPLEVBQUUsWUFBWSxDQUFDLENBQUM7S0FDbkMsQ0FBQyxDQUFDO0dBQ0o7O0FBRUQsbUJBQWlCLEVBQWpCLGlCQUFpQjtDQUNsQixDQUFDIiwiZmlsZSI6Ii92YXIvZm9sZGVycy93MS9fMm1jNm0wNTBxbjIzMm5wc2Y5ejNoZnNoNThfamgvVC90bXBpMzV6akdwdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLWNvbW1vbnMvbGliL3Byb21pc2VzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBiYWJlbCc7XG4vKiBAZmxvdyAqL1xuXG4vKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIGxpY2Vuc2UgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpblxuICogdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudHlwZSBSdW5SZXR1cm48VD4gPSB7XG4gIHN0YXR1czogJ3N1Y2Nlc3MnO1xuICByZXN1bHQ6IFQ7XG59IHwge1xuICBzdGF0dXM6ICdvdXRkYXRlZCc7XG59O1xuXG4vKipcbiAqIEFsbG93cyBhIGNhbGxlciB0byBlbnN1cmUgdGhhdCB0aGUgcmVzdWx0cyBpdCByZWNlaXZlcyBmcm9tIGNvbnNlY3V0aXZlXG4gKiBwcm9taXNlIHJlc29sdXRpb25zIGFyZSBuZXZlciBvdXRkYXRlZC4gVXNhZ2U6XG4gKlxuICogdmFyIHJlcXVlc3RTZXJpYWxpemVyID0gbmV3IFJlcXVlc3RTZXJpYWxpemVyKCk7XG4gKlxuICogLy8gaW4gc29tZSBsYXRlciBsb29wOlxuICpcbiAqIC8vIG5vdGUgdGhhdCB5b3UgZG8gbm90IGF3YWl0IHRoZSBhc3luYyBmdW5jdGlvbiBoZXJlIC0tIHlvdSBtdXN0IHBhc3MgdGhlXG4gKiAvLyBwcm9taXNlIGl0IHJldHVybnMgdG8gYHJ1bmBcbiAqIHZhciByZXN1bHQgPSBhd2FpdCByZXF1ZXN0U2VyaWFsaXplci5ydW4oc29tZUFzeW5jRnVuY3Rpb24oKSlcbiAqXG4gKiBpZiAocmVzdWx0LnN0YXR1cyA9PT0gJ3N1Y2Nlc3MnKSB7XG4gKiAgIC4uLi5cbiAqICAgcmVzdWx0LnJlc3VsdFxuICogfSBlbHNlIGlmIChyZXN1bHQuc3RhdHVzID09PSAnb3V0ZGF0ZWQnKSB7XG4gKiAgIC4uLi5cbiAqIH1cbiAqXG4gKiBUaGUgY29udHJhY3QgaXMgdGhhdCB0aGUgc3RhdHVzIGlzICdzdWNjZXNzJyBpZiBhbmQgb25seSBpZiB0aGlzIHdhcyB0aGUgbW9zdFxuICogcmVjZW50bHkgZGlzcGF0Y2hlZCBjYWxsIG9mICdydW4nLiBGb3IgZXhhbXBsZSwgaWYgeW91IGNhbGwgcnVuKHByb21pc2UxKSBhbmRcbiAqIHRoZW4gcnVuKHByb21pc2UyKSwgYW5kIHByb21pc2UyIHJlc29sdmVzIGZpcnN0LCB0aGUgc2Vjb25kIGNhbGxzaXRlIHdvdWxkXG4gKiByZWNlaXZlIGEgJ3N1Y2Nlc3MnIHN0YXR1cy4gSWYgcHJvbWlzZTEgbGF0ZXIgcmVzb2x2ZWQsIHRoZSBmaXJzdCBjYWxsc2l0ZVxuICogd291bGQgcmVjZWl2ZSBhbiAnb3V0ZGF0ZWQnIHN0YXR1cy5cbiAqL1xuY2xhc3MgUmVxdWVzdFNlcmlhbGl6ZXIge1xuICBfbGFzdERpc3BhdGNoZWRPcDogbnVtYmVyO1xuICBfbGFzdEZpbmlzaGVkT3A6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9sYXN0RGlzcGF0Y2hlZE9wID0gMDtcbiAgICB0aGlzLl9sYXN0RmluaXNoZWRPcCA9IDA7XG4gIH1cblxuICBhc3luYyBydW48VD4ocHJvbWlzZTogUHJvbWlzZTxUPik6IFByb21pc2U8UnVuUmV0dXJuPFQ+PiB7XG4gICAgdmFyIHRoaXNPcCA9IHRoaXMuX2xhc3REaXNwYXRjaGVkT3AgKyAxO1xuICAgIHRoaXMuX2xhc3REaXNwYXRjaGVkT3AgPSB0aGlzT3A7XG4gICAgdmFyIHJlc3VsdCA9IGF3YWl0IHByb21pc2U7XG4gICAgaWYgKHRoaXMuX2xhc3RGaW5pc2hlZE9wIDwgdGhpc09wKSB7XG4gICAgICB0aGlzLl9sYXN0RmluaXNoZWRPcCA9IHRoaXNPcDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogJ3N1Y2Nlc3MnLFxuICAgICAgICByZXN1bHQsXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6ICdvdXRkYXRlZCcsXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGlzUnVuSW5Qcm9ncmVzcygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fbGFzdERpc3BhdGNoZWRPcCA+IHRoaXMuX2xhc3RGaW5pc2hlZE9wO1xuICB9XG59XG5cbnZhciBwcm9taXNlcyA9IG1vZHVsZS5leHBvcnRzID0ge1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmFsdWUgZGVyaXZlZCBhc3luY2hyb25vdXNseSBmcm9tIGFuIGVsZW1lbnQgaW4gdGhlIGl0ZW1zIGFycmF5LlxuICAgKiBUaGUgdGVzdCBmdW5jdGlvbiBpcyBhcHBsaWVkIHNlcXVlbnRpYWxseSB0byBlYWNoIGVsZW1lbnQgaW4gaXRlbXMgdW50aWxcbiAgICogb25lIHJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBub24tbnVsbCB2YWx1ZS4gV2hlbiB0aGlzIGhhcHBlbnMsXG4gICAqIHRoZSBQcm9taXNlIHJldHVybmVkIGJ5IHRoaXMgbWV0aG9kIHdpbGwgcmVzb2x2ZSB0byB0aGF0IG5vbi1udWxsIHZhbHVlLiBJZlxuICAgKiBubyBzdWNoIFByb21pc2UgaXMgcHJvZHVjZWQsIHRoZW4gdGhlIFByb21pc2UgcmV0dXJuZWQgYnkgdGhpcyBmdW5jdGlvblxuICAgKiB3aWxsIHJlc29sdmUgdG8gbnVsbC5cbiAgICpcbiAgICogQHBhcmFtIGl0ZW1zIEFycmF5IG9mIGVsZW1lbnRzIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gdGVzdCwgb25lIGF0IGEgdGltZS5cbiAgICogQHBhcmFtIHRlc3QgV2lsbCBiZSBjYWxsZWQgd2l0aCBlYWNoIGl0ZW0gYW5kIG11c3QgcmV0dXJuIGVpdGhlcjpcbiAgICogICAgICgxKSBBIFwidGhlbmFibGVcIiAoaS5lLCBhIFByb21pc2Ugb3IgcHJvbWlzZS1saWtlIG9iamVjdCkgdGhhdCByZXNvbHZlc1xuICAgKiAgICAgICAgIHRvIGEgZGVyaXZlZCB2YWx1ZSAodGhhdCB3aWxsIGJlIHJldHVybmVkKSBvciBudWxsLlxuICAgKiAgICAgKDIpIG51bGwuXG4gICAqICAgICBJbiBib3RoIGNhc2VzIHdoZXJlIG51bGwgaXMgcmV0dXJuZWQsIHRlc3Qgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBuZXh0XG4gICAqICAgICBpdGVtIGluIHRoZSBhcnJheS5cbiAgICogQHBhcmFtIHRoaXNBcmcgUmVjZWl2ZXIgdGhhdCB3aWxsIGJlIHVzZWQgd2hlbiB0ZXN0IGlzIGNhbGxlZC5cbiAgICogQHJldHVybiBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gYXN5bmNocm9ub3VzbHkgZGVyaXZlZCB2YWx1ZSBvciBudWxsLlxuICAgKi9cbiAgYXN5bmNGaW5kPFQsIFU+KGl0ZW1zOiBBcnJheTxUPiwgdGVzdDogKHQ6IFQpID0+ID9Qcm9taXNlPFU+LCB0aGlzQXJnPzogbWl4ZWQpOiBQcm9taXNlPD9VPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIC8vIENyZWF0ZSBhIGxvY2FsIGNvcHkgb2YgaXRlbXMgdG8gZGVmZW5kIGFnYWluc3QgdGhlIGNhbGxlciBtb2RpZnlpbmcgdGhlXG4gICAgICAvLyBhcnJheSBiZWZvcmUgdGhpcyBQcm9taXNlIGlzIHJlc29sdmVkLlxuICAgICAgaXRlbXMgPSBpdGVtcy5zbGljZSgpO1xuICAgICAgdmFyIG51bUl0ZW1zID0gaXRlbXMubGVuZ3RoO1xuXG4gICAgICB2YXIgbmV4dCA9IGFzeW5jIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA9PT0gbnVtSXRlbXMpIHtcbiAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpdGVtID0gaXRlbXNbaW5kZXhdO1xuICAgICAgICB2YXIgcmVzdWx0ID0gYXdhaXQgdGVzdC5jYWxsKHRoaXNBcmcsIGl0ZW0pO1xuICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHQoaW5kZXggKyAxKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgbmV4dCgwKTtcbiAgICB9KTtcbiAgfSxcblxuICBkZW5vZGVpZnkoZjogKC4uLmFyZ3M6IEFycmF5PGFueT4pID0+IGFueSk6ICguLi5hcmdzOiBBcnJheTxhbnk+KSA9PiBQcm9taXNlPGFueT4ge1xuICAgIHJldHVybiBmdW5jdGlvbiguLi5hcmdzOiBBcnJheTxhbnk+KSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBmdW5jdGlvbiBjYWxsYmFjayhlcnJvciwgcmVzdWx0KSB7XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGYuYXBwbHkodGhpcywgYXJncy5jb25jYXQoW2NhbGxiYWNrXSkpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogQSBQcm9taXNlIHV0aWxpdHkgdGhhdCBydW5zIGEgbWF4aW11bSBvZiBsaW1pdCBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZSBpdGVyYXRpbmcgb3ZlciBhbiBhcnJheVxuICAgKiBhbmQgcmV0dXJuaW5nIHRoZSByZXN1bHQgb2YgZXhlY3V0aW9ucy5cbiAgICogZS5nLiB0byBsaW1pdCB0aGUgbnVtYmVyIG9mIGZpbGUgcmVhZHMgdG8gNSxcbiAgICogcmVwbGFjZSB0aGUgY29kZTpcbiAgICogICAgdmFyIGZpbGVDb250ZW50cyA9IGF3YWl0IFByb21pc2UuYWxsKGZpbGVQYXRocy5tYXAoZnNQcm9taXNlLnJlYWRGaWxlKSlcbiAgICogd2l0aDpcbiAgICogICAgdmFyIGZpbGVDb250ZW50cyA9IGF3YWl0IGFzeW5jTGltaXQoZmlsZVBhdGhzLCA1LCBmc1Byb21pc2UucmVhZEZpbGUpXG4gICAqXG4gICAqIFRoaXMgaXMgcGFydGljdWxyaWx5IHVzZWZ1bCB0byBsaW1pdCBJTyBvcGVyYXRpb25zIHRvIGEgY29uZmlndXJhYmxlIG1heGltdW0gKHRvIGF2b2lkIGJsb2NraW5nKSxcbiAgICogd2hpbGUgZW5qb3lpbmcgdGhlIGNvbmZpZ3VyZWQgbGV2ZWwgb2YgcGFyYWxsZWxpc20uXG4gICAqXG4gICAqIEBwYXJhbSBhcnJheSB0aGUgYXJyYXkgb2YgaXRlbXMgZm9yIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIGxpbWl0IHRoZSBjb25maWd1cmFibGUgbnVtYmVyIG9mIHBhcmFsbGVsIGFzeW5jIG9wZXJhdGlvbnMuXG4gICAqIEBwYXJhbSBtYXBwaW5nRnVuY3Rpb24gdGhlIGFzeW5jIFByb21pc2UgZnVuY3Rpb24gdGhhdCBjb3VsZCByZXR1cm4gYSB1c2VmdWwgcmVzdWx0LlxuICAgKi9cbiAgYXN5bmNMaW1pdDxULCBWPihhcnJheTogQXJyYXk8VD4sIGxpbWl0OiBudW1iZXIsIG1hcHBpbmdGdW5jdGlvbjogKGl0ZW06IFQpID0+IFByb21pc2U8Vj4pOiBQcm9taXNlPEFycmF5PFY+PiB7XG4gICAgdmFyIHJlc3VsdDogQXJyYXk8Vj4gPSBuZXcgQXJyYXkoYXJyYXkubGVuZ3RoKTtcbiAgICB2YXIgcGFyYWxsZWxQcm9taXNlcyA9IDA7XG4gICAgdmFyIGluZGV4ID0gMDtcblxuICAgIHZhciBwYXJhbGxlbExpbWl0ID0gTWF0aC5taW4obGltaXQsIGFycmF5Lmxlbmd0aCk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdmFyIHJ1blByb21pc2UgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmIChpbmRleCA9PT0gYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKHBhcmFsbGVsUHJvbWlzZXMgPT09IDApIHtcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgICsrcGFyYWxsZWxQcm9taXNlcztcbiAgICAgICAgdmFyIGkgPSBpbmRleCsrO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3VsdFtpXSA9IGF3YWl0IG1hcHBpbmdGdW5jdGlvbihhcnJheVtpXSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgICAgLS1wYXJhbGxlbFByb21pc2VzO1xuICAgICAgICBydW5Qcm9taXNlKCk7XG4gICAgICB9O1xuXG4gICAgICB3aGlsZSAocGFyYWxsZWxQcm9taXNlcyA8IHBhcmFsbGVsTGltaXQpIHtcbiAgICAgICAgcnVuUHJvbWlzZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBgZmlsdGVyYCBQcm9taXNlIHV0aWxpdHkgdGhhdCBhbGxvd3MgZmlsdGVyaW5nIGFuIGFycmF5IHdpdGggYW4gYXN5bmMgUHJvbWlzZSBmdW5jdGlvbi5cbiAgICogSXQncyBhbiBhbHRlcm5hdGl2ZSB0byBgQXJyYXkucHJvdG90eXBlLmZpbHRlcmAgdGhhdCBhY2NlcHRzIGFuIGFzeW5jIGZ1bmN0aW9uLlxuICAgKiBZb3UgY2FuIG9wdGlvbmFsbHkgY29uZmlndXJlIGEgbGltaXQgdG8gc2V0IHRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAgICpcbiAgICogUHJldmlvdXNseSwgd2l0aCB0aGUgYFByb21pc2UuYWxsYCBwcmltaXRpdmUsIHdlIGNhbid0IHNldCB0aGUgcGFyYWxsZWxpc20gbGltaXQgYW5kIHdlIGhhdmUgdG9cbiAgICogYGZpbHRlcmAsIHNvLCB3ZSByZXBsYWNlIHRoZSBvbGQgYGZpbHRlcmAgY29kZTpcbiAgICogICAgIHZhciBleGlzdGluZ0ZpbGVQYXRocyA9IFtdO1xuICAgKiAgICAgYXdhaXQgUHJvbWlzZS5hbGwoZmlsZVBhdGhzLm1hcChhc3luYyAoZmlsZVBhdGgpID0+IHtcbiAgICogICAgICAgaWYgKGF3YWl0IGZzUHJvbWlzZS5leGlzdHMoZmlsZVBhdGgpKSB7XG4gICAqICAgICAgICAgZXhpc3RpbmdGaWxlUGF0aHMucHVzaChmaWxlUGF0aCk7XG4gICAqICAgICAgIH1cbiAgICogICAgIH0pKTtcbiAgICogd2l0aCBsaW1pdCA1IHBhcmFsbGVsIGZpbGVzeXN0ZW0gb3BlcmF0aW9ucyBhdCBhIHRpbWU6XG4gICAqICAgIHZhciBleGlzdGluZ0ZpbGVQYXRocyA9IGF3YWl0IGFzeW5jRmlsdGVyKGZpbGVQYXRocywgZnNQcm9taXNlLmV4aXN0cywgNSk7XG4gICAqXG4gICAqIEBwYXJhbSBhcnJheSB0aGUgYXJyYXkgb2YgaXRlbXMgZm9yIGBmaWx0ZXJgaW5nLlxuICAgKiBAcGFyYW0gZmlsdGVyRnVuY3Rpb24gdGhlIGFzeW5jIGBmaWx0ZXJgIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGJvb2xlYW4uXG4gICAqIEBwYXJhbSBsaW1pdCB0aGUgY29uZmlndXJhYmxlIG51bWJlciBvZiBwYXJhbGxlbCBhc3luYyBvcGVyYXRpb25zLlxuICAgKi9cbiAgYXN5bmMgYXN5bmNGaWx0ZXI8VD4oYXJyYXk6IEFycmF5PFQ+LCBmaWx0ZXJGdW5jdGlvbjogKGl0ZW06IFQpID0+IFByb21pc2U8Ym9vbGVhbj4sIGxpbWl0PzogbnVtYmVyKTogUHJvbWlzZTxBcnJheTxUPj4ge1xuICAgIHZhciBmaWx0ZXJlZExpc3QgPSBbXTtcbiAgICBhd2FpdCBwcm9taXNlcy5hc3luY0xpbWl0KGFycmF5LCBsaW1pdCB8fCBhcnJheS5sZW5ndGgsIGFzeW5jIChpdGVtOiBUKSA9PiB7XG4gICAgICBpZiAoYXdhaXQgZmlsdGVyRnVuY3Rpb24oaXRlbSkpIHtcbiAgICAgICAgZmlsdGVyZWRMaXN0LnB1c2goaXRlbSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZpbHRlcmVkTGlzdDtcbiAgfSxcblxuICAvKipcbiAgICogYHNvbWVgIFByb21pc2UgdXRpbGl0eSB0aGF0IGFsbG93cyBgc29tZWAgYW4gYXJyYXkgd2l0aCBhbiBhc3luYyBQcm9taXNlIHNvbWUgZnVuY3Rpb24uXG4gICAqIEl0J3MgYW4gYWx0ZXJuYXRpdmUgdG8gYEFycmF5LnByb3RvdHlwZS5zb21lYCB0aGF0IGFjY2VwdHMgYW4gYXN5bmMgc29tZSBmdW5jdGlvbi5cbiAgICogWW91IGNhbiBvcHRpb25hbGx5IGNvbmZpZ3VyZSBhIGxpbWl0IHRvIHNldCB0aGUgbWF4aW11bSBudW1iZXIgb2YgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuXG4gICAqXG4gICAqIFByZXZpb3VzbHksIHdpdGggdGhlIFByb21pc2UuYWxsIHByaW1pdGl2ZSwgd2UgY2FuJ3Qgc2V0IHRoZSBwYXJhbGxlbGlzbSBsaW1pdCBhbmQgd2UgaGF2ZSB0b1xuICAgKiBgc29tZWAsIHNvLCB3ZSByZXBsYWNlIHRoZSBvbGQgYHNvbWVgIGNvZGU6XG4gICAqICAgICB2YXIgc29tZUZpbGVFeGlzdCA9IGZhbHNlO1xuICAgKiAgICAgYXdhaXQgUHJvbWlzZS5hbGwoZmlsZVBhdGhzLm1hcChhc3luYyAoZmlsZVBhdGgpID0+IHtcbiAgICogICAgICAgaWYgKGF3YWl0IGZzUHJvbWlzZS5leGlzdHMoZmlsZVBhdGgpKSB7XG4gICAqICAgICAgICAgc29tZUZpbGVFeGlzdCA9IHRydWU7XG4gICAqICAgICAgIH1cbiAgICogICAgIH0pKTtcbiAgICogd2l0aCBsaW1pdCA1IHBhcmFsbGVsIGZpbGVzeXN0ZW0gb3BlcmF0aW9ucyBhdCBhIHRpbWU6XG4gICAqICAgIHZhciBzb21lRmlsZUV4aXN0ID0gYXdhaXQgYXN5bmNTb21lKGZpbGVQYXRocywgZnNQcm9taXNlLmV4aXN0cywgNSk7XG4gICAqXG4gICAqIEBwYXJhbSBhcnJheSB0aGUgYXJyYXkgb2YgaXRlbXMgZm9yIGBzb21lYGluZy5cbiAgICogQHBhcmFtIHNvbWVGdW5jdGlvbiB0aGUgYXN5bmMgYHNvbWVgIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGJvb2xlYW4uXG4gICAqIEBwYXJhbSBsaW1pdCB0aGUgY29uZmlndXJhYmxlIG51bWJlciBvZiBwYXJhbGxlbCBhc3luYyBvcGVyYXRpb25zLlxuICAgKi9cbiAgYXN5bmMgYXN5bmNTb21lPFQ+KGFycmF5OiBBcnJheTxUPiwgc29tZUZ1bmN0aW9uOiAoaXRlbTogVCkgPT4gUHJvbWlzZTxib29sZWFuPiwgbGltaXQ/OiBudW1iZXIpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICB2YXIgcmVzb2x2ZWQgPSBmYWxzZTtcbiAgICBhd2FpdCBwcm9taXNlcy5hc3luY0xpbWl0KGFycmF5LCBsaW1pdCB8fCBhcnJheS5sZW5ndGgsIGFzeW5jIChpdGVtOiBUKSA9PiB7XG4gICAgICBpZiAocmVzb2x2ZWQpIHtcbiAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBjYWxsIHRoZSBzb21lRnVuY3Rpb24gYW55bW9yZSBvciB3YWl0IGFueSBsb25nZXIuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChhd2FpdCBzb21lRnVuY3Rpb24oaXRlbSkpIHtcbiAgICAgICAgcmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXNvbHZlZDtcbiAgfSxcblxuICAvKlxuICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSBhZnRlciBgbWlsbGlTZWNvbmRzYCBtaWxsaSBzZWNvbmRzLlxuICAgKiB0aGlzIGNhbiBiZSB1c2VkIHRvIHBhdXNlIGV4ZWN1dGlvbiBhc3luY2hyb25vdXNseS5cbiAgICogZS5nLiBhd2FpdCBhd2FpdE1pbGxpU2Vjb25kcygxMDAwKSwgcGF1c2VzIHRoZSBhc3luYyBmbG93IGV4ZWN1dGlvbiBmb3IgMSBzZWNvbmQuXG4gICAqL1xuICBhd2FpdE1pbGxpU2Vjb25kcyhtaWxsaVNlY29uZHM6IG51bWJlcik6IFByb21pc2Uge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIG1pbGxpU2Vjb25kcyk7XG4gICAgfSk7XG4gIH0sXG5cbiAgUmVxdWVzdFNlcmlhbGl6ZXIsXG59O1xuIl19
