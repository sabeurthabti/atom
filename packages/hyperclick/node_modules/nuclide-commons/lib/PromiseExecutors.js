Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

var _dequeue = require('dequeue');

var _dequeue2 = _interopRequireDefault(_dequeue);

var _events = require('events');

'use babel';

/**
 * A pool that executes Promise executors in parallel given the poolSize, in order.
 *
 * The executor function passed to the constructor of a Promise is evaluated
 * immediately. This may not always be desirable. Use a PromisePool if you have
 * a sequence of async operations that need to be run in parallel and you also want
 * control the number of concurrent executions.
 */

var PromisePool = (function () {
  function PromisePool(poolSize) {
    _classCallCheck(this, PromisePool);

    this._fifo = new _dequeue2['default']();
    this._emitter = new _events.EventEmitter();
    this._numPromisesRunning = 0;
    this._poolSize = poolSize;
    this._nextRequestId = 1;
  }

  /**
   * FIFO queue that executes Promise executors one at a time, in order.
   *
   * The executor function passed to the constructor of a Promise is evaluated
   * immediately. This may not always be desirable. Use a PromiseQueue if you have
   * a sequence of async operations that need to use a shared resource serially.
   */

  /**
   * @param executor A function that takes resolve and reject callbacks, just
   *     like the Promise constructor.
   * @return A Promise that will be resolved/rejected in response to the
   *     execution of the executor.
   */

  _createClass(PromisePool, [{
    key: 'submit',
    value: function submit(executor) {
      var _this = this;

      var id = this._getNextRequestId();
      this._fifo.push({ id: id, executor: executor });
      var promise = new Promise(function (resolve, reject) {
        _this._emitter.once(id, function (result) {
          var isSuccess = result.isSuccess;
          var value = result.value;

          (isSuccess ? resolve : reject)(value);
        });
      });
      this._run();
      return promise;
    }
  }, {
    key: '_run',
    value: function _run() {
      var _this2 = this;

      if (this._numPromisesRunning === this._poolSize) {
        return;
      }

      if (this._fifo.length === 0) {
        return;
      }

      var _fifo$shift = this._fifo.shift();

      var id = _fifo$shift.id;
      var executor = _fifo$shift.executor;

      this._numPromisesRunning++;
      new Promise(executor).then(function (result) {
        _this2._emitter.emit(id, { isSuccess: true, value: result });
        _this2._numPromisesRunning--;
        _this2._run();
      }, function (error) {
        _this2._emitter.emit(id, { isSuccess: false, value: error });
        _this2._numPromisesRunning--;
        _this2._run();
      });
    }
  }, {
    key: '_getNextRequestId',
    value: function _getNextRequestId() {
      return (this._nextRequestId++).toString(16);
    }
  }]);

  return PromisePool;
})();

exports.PromisePool = PromisePool;

var PromiseQueue = (function () {
  function PromiseQueue() {
    _classCallCheck(this, PromiseQueue);

    this._promisePool = new PromisePool(1);
  }

  /**
   * @param executor A function that takes resolve and reject callbacks, just
   *     like the Promise constructor.
   * @return A Promise that will be resolved/rejected in response to the
   *     execution of the executor.
   */

  _createClass(PromiseQueue, [{
    key: 'submit',
    value: function submit(executor) {
      return this._promisePool.submit(executor);
    }
  }]);

  return PromiseQueue;
})();

exports.PromiseQueue = PromiseQueue;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy93MS9fMm1jNm0wNTBxbjIzMm5wc2Y5ejNoZnNoNThfamgvVC90bXBpMzV6akdwdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLWNvbW1vbnMvbGliL1Byb21pc2VFeGVjdXRvcnMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O3VCQVVvQixTQUFTOzs7O3NCQUNGLFFBQVE7O0FBWG5DLFdBQVcsQ0FBQzs7Ozs7Ozs7Ozs7SUF1QkMsV0FBVztBQU9YLFdBUEEsV0FBVyxDQU9WLFFBQWdCLEVBQUU7MEJBUG5CLFdBQVc7O0FBUXBCLFFBQUksQ0FBQyxLQUFLLEdBQUcsMEJBQWEsQ0FBQztBQUMzQixRQUFJLENBQUMsUUFBUSxHQUFHLFlBckJaLFlBQVksRUFxQmtCLENBQUM7QUFDbkMsUUFBSSxDQUFDLG1CQUFtQixHQUFHLENBQUMsQ0FBQztBQUM3QixRQUFJLENBQUMsU0FBUyxHQUFHLFFBQVEsQ0FBQztBQUMxQixRQUFJLENBQUMsY0FBYyxHQUFHLENBQUMsQ0FBQztHQUN6Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7ZUFiVSxXQUFXOztXQXFCaEIsZ0JBQUMsUUFBa0IsRUFBVzs7O0FBQ2xDLFVBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO0FBQ2xDLFVBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFDLENBQUMsQ0FBQztBQUM5QyxVQUFJLE9BQU8sR0FBRyxJQUFJLE9BQU8sQ0FBQyxVQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUs7QUFDN0MsY0FBSyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxVQUFDLE1BQU0sRUFBSztjQUM1QixTQUFTLEdBQVcsTUFBTSxDQUExQixTQUFTO2NBQUUsS0FBSyxHQUFJLE1BQU0sQ0FBZixLQUFLOztBQUNyQixXQUFDLFNBQVMsR0FBRyxPQUFPLEdBQUcsTUFBTSxDQUFBLENBQUUsS0FBSyxDQUFDLENBQUM7U0FDdkMsQ0FBQyxDQUFDO09BQ0osQ0FBQyxDQUFDO0FBQ0gsVUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO0FBQ1osYUFBTyxPQUFPLENBQUM7S0FDaEI7OztXQUVHLGdCQUFHOzs7QUFDTCxVQUFJLElBQUksQ0FBQyxtQkFBbUIsS0FBSyxJQUFJLENBQUMsU0FBUyxFQUFFO0FBQy9DLGVBQU87T0FDUjs7QUFFRCxVQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtBQUMzQixlQUFPO09BQ1I7O3dCQUVvQixJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRTs7VUFBbEMsRUFBRSxlQUFGLEVBQUU7VUFBRSxRQUFRLGVBQVIsUUFBUTs7QUFDakIsVUFBSSxDQUFDLG1CQUFtQixFQUFFLENBQUM7QUFDM0IsVUFBSSxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQUMsTUFBTSxFQUFLO0FBQ3JDLGVBQUssUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsRUFBQyxTQUFTLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUMsQ0FBQyxDQUFDO0FBQ3pELGVBQUssbUJBQW1CLEVBQUUsQ0FBQztBQUMzQixlQUFLLElBQUksRUFBRSxDQUFDO09BQ2IsRUFBRSxVQUFDLEtBQUssRUFBSztBQUNaLGVBQUssUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsRUFBQyxTQUFTLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUMsQ0FBQyxDQUFDO0FBQ3pELGVBQUssbUJBQW1CLEVBQUUsQ0FBQztBQUMzQixlQUFLLElBQUksRUFBRSxDQUFDO09BQ2IsQ0FBQyxDQUFDO0tBQ0o7OztXQUVnQiw2QkFBVztBQUMxQixhQUFPLENBQUMsSUFBSSxDQUFDLGNBQWMsR0FBRSxDQUFFLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQztLQUM3Qzs7O1NBMURVLFdBQVc7Ozs7O0lBb0VYLFlBQVk7QUFHWixXQUhBLFlBQVksR0FHVDswQkFISCxZQUFZOztBQUlyQixRQUFJLENBQUMsWUFBWSxHQUFHLElBQUksV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDO0dBQ3hDOzs7Ozs7Ozs7ZUFMVSxZQUFZOztXQWFqQixnQkFBQyxRQUFrQixFQUFXO0FBQ2xDLGFBQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7S0FDM0M7OztTQWZVLFlBQVkiLCJmaWxlIjoiL3Zhci9mb2xkZXJzL3cxL18ybWM2bTA1MHFuMjMybnBzZjl6M2hmc2g1OF9qaC9UL3RtcGkzNXpqR3B1Ymxpc2hfcGFja2FnZXMvbnBtL251Y2xpZGUtY29tbW9ucy9saWIvUHJvbWlzZUV4ZWN1dG9ycy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2UgYmFiZWwnO1xuLyogQGZsb3cgKi9cblxuLypcbiAqIENvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBsaWNlbnNlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW5cbiAqIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5pbXBvcnQgRGVxdWV1ZSBmcm9tICdkZXF1ZXVlJztcbmltcG9ydCB7RXZlbnRFbWl0dGVyfSBmcm9tICdldmVudHMnO1xuXG50eXBlIEV4ZWN1dG9yID0gKHJlc29sdmU6IGFueSwgcmVqZWN0OiBhbnkpID0+IHZvaWQ7XG5cbi8qKlxuICogQSBwb29sIHRoYXQgZXhlY3V0ZXMgUHJvbWlzZSBleGVjdXRvcnMgaW4gcGFyYWxsZWwgZ2l2ZW4gdGhlIHBvb2xTaXplLCBpbiBvcmRlci5cbiAqXG4gKiBUaGUgZXhlY3V0b3IgZnVuY3Rpb24gcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3RvciBvZiBhIFByb21pc2UgaXMgZXZhbHVhdGVkXG4gKiBpbW1lZGlhdGVseS4gVGhpcyBtYXkgbm90IGFsd2F5cyBiZSBkZXNpcmFibGUuIFVzZSBhIFByb21pc2VQb29sIGlmIHlvdSBoYXZlXG4gKiBhIHNlcXVlbmNlIG9mIGFzeW5jIG9wZXJhdGlvbnMgdGhhdCBuZWVkIHRvIGJlIHJ1biBpbiBwYXJhbGxlbCBhbmQgeW91IGFsc28gd2FudFxuICogY29udHJvbCB0aGUgbnVtYmVyIG9mIGNvbmN1cnJlbnQgZXhlY3V0aW9ucy5cbiAqL1xuZXhwb3J0IGNsYXNzIFByb21pc2VQb29sIHtcbiAgX2ZpZm86IERlcXVldWU7XG4gIF9lbWl0dGVyOiBFdmVudEVtaXR0ZXI7XG4gIF9udW1Qcm9taXNlc1J1bm5pbmc6IG51bWJlcjtcbiAgX3Bvb2xTaXplOiBudW1iZXI7XG4gIF9uZXh0UmVxdWVzdElkOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IocG9vbFNpemU6IG51bWJlcikge1xuICAgIHRoaXMuX2ZpZm8gPSBuZXcgRGVxdWV1ZSgpO1xuICAgIHRoaXMuX2VtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgdGhpcy5fbnVtUHJvbWlzZXNSdW5uaW5nID0gMDtcbiAgICB0aGlzLl9wb29sU2l6ZSA9IHBvb2xTaXplO1xuICAgIHRoaXMuX25leHRSZXF1ZXN0SWQgPSAxO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBleGVjdXRvciBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgcmVzb2x2ZSBhbmQgcmVqZWN0IGNhbGxiYWNrcywganVzdFxuICAgKiAgICAgbGlrZSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3Rvci5cbiAgICogQHJldHVybiBBIFByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkL3JlamVjdGVkIGluIHJlc3BvbnNlIHRvIHRoZVxuICAgKiAgICAgZXhlY3V0aW9uIG9mIHRoZSBleGVjdXRvci5cbiAgICovXG4gIHN1Ym1pdChleGVjdXRvcjogRXhlY3V0b3IpOiBQcm9taXNlIHtcbiAgICB2YXIgaWQgPSB0aGlzLl9nZXROZXh0UmVxdWVzdElkKCk7XG4gICAgdGhpcy5fZmlmby5wdXNoKHtpZDogaWQsIGV4ZWN1dG9yOiBleGVjdXRvcn0pO1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5fZW1pdHRlci5vbmNlKGlkLCAocmVzdWx0KSA9PiB7XG4gICAgICAgIHZhciB7aXNTdWNjZXNzLCB2YWx1ZX0gPSByZXN1bHQ7XG4gICAgICAgIChpc1N1Y2Nlc3MgPyByZXNvbHZlIDogcmVqZWN0KSh2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLl9ydW4oKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIF9ydW4oKSB7XG4gICAgaWYgKHRoaXMuX251bVByb21pc2VzUnVubmluZyA9PT0gdGhpcy5fcG9vbFNpemUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZmlmby5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIge2lkLCBleGVjdXRvcn0gPSB0aGlzLl9maWZvLnNoaWZ0KCk7XG4gICAgdGhpcy5fbnVtUHJvbWlzZXNSdW5uaW5nKys7XG4gICAgbmV3IFByb21pc2UoZXhlY3V0b3IpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgdGhpcy5fZW1pdHRlci5lbWl0KGlkLCB7aXNTdWNjZXNzOiB0cnVlLCB2YWx1ZTogcmVzdWx0fSk7XG4gICAgICB0aGlzLl9udW1Qcm9taXNlc1J1bm5pbmctLTtcbiAgICAgIHRoaXMuX3J1bigpO1xuICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgdGhpcy5fZW1pdHRlci5lbWl0KGlkLCB7aXNTdWNjZXNzOiBmYWxzZSwgdmFsdWU6IGVycm9yfSk7XG4gICAgICB0aGlzLl9udW1Qcm9taXNlc1J1bm5pbmctLTtcbiAgICAgIHRoaXMuX3J1bigpO1xuICAgIH0pO1xuICB9XG5cbiAgX2dldE5leHRSZXF1ZXN0SWQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gKHRoaXMuX25leHRSZXF1ZXN0SWQrKykudG9TdHJpbmcoMTYpO1xuICB9XG59XG5cbi8qKlxuICogRklGTyBxdWV1ZSB0aGF0IGV4ZWN1dGVzIFByb21pc2UgZXhlY3V0b3JzIG9uZSBhdCBhIHRpbWUsIGluIG9yZGVyLlxuICpcbiAqIFRoZSBleGVjdXRvciBmdW5jdGlvbiBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yIG9mIGEgUHJvbWlzZSBpcyBldmFsdWF0ZWRcbiAqIGltbWVkaWF0ZWx5LiBUaGlzIG1heSBub3QgYWx3YXlzIGJlIGRlc2lyYWJsZS4gVXNlIGEgUHJvbWlzZVF1ZXVlIGlmIHlvdSBoYXZlXG4gKiBhIHNlcXVlbmNlIG9mIGFzeW5jIG9wZXJhdGlvbnMgdGhhdCBuZWVkIHRvIHVzZSBhIHNoYXJlZCByZXNvdXJjZSBzZXJpYWxseS5cbiAqL1xuZXhwb3J0IGNsYXNzIFByb21pc2VRdWV1ZSB7XG4gIF9wcm9taXNlUG9vbDogUHJvbWlzZVBvb2w7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fcHJvbWlzZVBvb2wgPSBuZXcgUHJvbWlzZVBvb2woMSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIGV4ZWN1dG9yIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyByZXNvbHZlIGFuZCByZWplY3QgY2FsbGJhY2tzLCBqdXN0XG4gICAqICAgICBsaWtlIHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yLlxuICAgKiBAcmV0dXJuIEEgUHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQvcmVqZWN0ZWQgaW4gcmVzcG9uc2UgdG8gdGhlXG4gICAqICAgICBleGVjdXRpb24gb2YgdGhlIGV4ZWN1dG9yLlxuICAgKi9cbiAgc3VibWl0KGV4ZWN1dG9yOiBFeGVjdXRvcik6IFByb21pc2Uge1xuICAgIHJldHVybiB0aGlzLl9wcm9taXNlUG9vbC5zdWJtaXQoZXhlY3V0b3IpO1xuICB9XG59XG4iXX0=
