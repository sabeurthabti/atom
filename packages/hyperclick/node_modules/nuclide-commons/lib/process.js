
/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

/**
 * Since OS X apps don't inherit PATH when not launched from the CLI, this function creates a new
 * environment object given the original environment by modifying the env.PATH using following
 * logic:
 *  1) If originalEnv.PATH doesn't equal to process.env.PATH, which means the PATH has been
 *    modified, we shouldn't do anything.
 *  1) If we are running in OS X, use `/usr/libexec/path_helper -s` to get the correct PATH and
 *    REPLACE the PATH.
 *  2) If step 1 failed or we are not running in OS X, APPEND commonBinaryPaths to current PATH.
 */

var createExecEnvironment = _asyncToGenerator(function* (originalEnv, commonBinaryPaths) {
  var execEnv = _extends({}, originalEnv);

  if (execEnv.PATH !== process.env.PATH) {
    return execEnv;
  }

  execEnv.PATH = execEnv.PATH || '';

  var platformPath = null;
  try {
    platformPath = yield getPlatformPath();
  } catch (error) {
    logError('Failed to getPlatformPath', error);
  }

  // If the platform returns a non-empty PATH, use it. Otherwise use the default set of common
  // binary paths.
  if (platformPath) {
    execEnv.PATH = platformPath;
  } else {
    appendCommonBinaryPaths(execEnv, commonBinaryPaths);
  }

  return execEnv;
});

/** Basically like spawn, except it handles and logs errors instead of crashing
  * the process. This is much lower-level than asyncExecute. Unless you have a
  * specific reason you should use asyncExecute instead. */

var safeSpawn = _asyncToGenerator(function* (command) {
  var args = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  options.env = yield createExecEnvironment(options.env || process.env, COMMON_BINARY_PATHS);
  var child = spawn(command, args, options);
  monitorStreamErrors(child, command, args, options);
  child.on('error', function (error) {
    logError('error with command:', command, args, options, 'error:', error);
  });
  return child;
});

var asyncExecute = _asyncToGenerator(function* (command, args) {
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  var result = yield checkOutput(command, args, options);
  if (result.exitCode !== 0) {
    // TODO(t8215539): Add properties such as "message" and "toString()" so that if the caller
    // catches this as if it were an error, it will print nicely rather than "[object Object]".
    throw result;
  }
  return result;
});

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { var callNext = step.bind(null, 'next'); var callThrow = step.bind(null, 'throw'); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(callNext, callThrow); } } callNext(); }); }; }

var _require = require('child_process');

var execFile = _require.execFile;
var spawn = _require.spawn;

var path = require('path');

var _require2 = require('./PromiseExecutors');

var PromiseQueue = _require2.PromiseQueue;

var platformPathPromise;

var blockingQueues = {};
var COMMON_BINARY_PATHS = ['/usr/bin', '/bin', '/usr/sbin', '/sbin', '/usr/local/bin'];

/* Captures the value of the PATH env variable returned by Darwin's (OS X) `path_helper` utility.
 * `path_helper -s`'s return value looks like this:
 *
 *     PATH="/usr/bin"; export PATH;
 */
var DARWIN_PATH_HELPER_REGEXP = /PATH=\"([^\"]+)\"/;

var STREAM_NAMES = ['stdin', 'stdout', 'stderr'];

function getPlatformPath() {
  if (platformPathPromise) {
    // Path is being fetched, await the Promise that's in flight.
    return platformPathPromise;
  }

  if (process.platform === 'darwin') {
    // OS X apps don't inherit PATH when not launched from the CLI, so reconstruct it. This is a
    // bug, filed against Atom Linter here: https://github.com/AtomLinter/Linter/issues/150
    // TODO(jjiaa): remove this hack when the Atom issue is closed
    platformPathPromise = new Promise(function (resolve, reject) {
      execFile('/usr/libexec/path_helper', ['-s'], function (error, stdout, stderr) {
        if (error) {
          reject(error);
        } else {
          var match = stdout.match(DARWIN_PATH_HELPER_REGEXP);
          resolve(match && match.length > 1 ? match[1] : '');
        }
      });
    });
  } else {
    platformPathPromise = Promise.resolve('');
  }

  return platformPathPromise;
}

function appendCommonBinaryPaths(env, commonBinaryPaths) {
  commonBinaryPaths.forEach(function (binaryPath) {
    if (env.PATH.indexOf(binaryPath) === -1) {
      env.PATH += path.delimiter + binaryPath;
    }
  });
}

function logError() {
  // Can't use nuclide-logging here to not cause cycle dependency.
  /*eslint-disable no-console*/
  console.error.apply(console, arguments);
  /*eslint-enable no-console*/
}

function monitorStreamErrors(process, command, args, options) {
  STREAM_NAMES.forEach(function (streamName) {
    // $FlowIssue
    process[streamName].on('error', function (error) {
      // This can happen without the full execution of the command to fail, but we want to learn about it.
      logError('stream error with command:', command, args, options, 'error:', error);
    });
  });
}

var isOsX = process.platform === 'darwin';

/**
 * Takes the command and args that you would normally pass to `spawn()` and returns `newArgs` such
 * that you should call it with `spawn('script', newArgs)` to run the original command/args pair
 * under `script`.
 */
function createArgsForScriptCommand(command) {
  var args = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];

  if (isOsX) {
    // On OS X, script takes the program to run and its arguments as varargs at the end.
    return ['-q', '/dev/null', command].concat(args);
  } else {
    // On Linux, script takes the command to run as the -c parameter.
    // TODO: Shell escape every element in allArgs.
    var allArgs = [command].concat(args);
    var commandAsItsOwnArg = allArgs.join(' ');
    return ['-q', '/dev/null', '-c', commandAsItsOwnArg];
  }
}

/**
 * Basically like safeSpawn, but runs the command with the `script` command.
 * `script` ensures terminal-like environment and commands we run give colored output.
 */
function scriptSafeSpawn(command) {
  var args = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  var newArgs = createArgsForScriptCommand(command, args);
  return safeSpawn('script', newArgs, options);
}

/**
 * Returns a promise that resolves to the result of executing a process.
 *
 * @param command The command to execute.
 * @param args The arguments to pass to the command.
 * @param options Options for changing how to run the command.
 *     See here: http://nodejs.org/api/child_process.html
 *     The additional options we provide:
 *       queueName string The queue on which to block dependent calls.
 *       stdin string The contents to write to stdin.
 *       pipedCommand string a command to pipe the output of command through.
 *       pipedArgs array of strings as arguments.
 * @return Promise that resolves to an object with the properties:
 *     stdout string The contents of the process's output stream.
 *     stderr string The contents of the process's error stream.
 *     exitCode number The exit code returned by the process.
 */
function checkOutput(command, args) {
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  // Clone passed in options so this function doesn't modify an object it doesn't own.
  var localOptions = _extends({}, options);

  var executor = function executor(resolve, reject) {
    var firstChild;
    var lastChild;

    var firstChildStderr;
    if (localOptions.pipedCommand) {
      // If a second command is given, pipe stdout of first to stdin of second. String output
      // returned in this function's Promise will be stderr/stdout of the second command.
      firstChild = spawn(command, args, localOptions);
      monitorStreamErrors(firstChild, command, args, localOptions);
      firstChildStderr = '';

      firstChild.on('error', function (error) {
        // Reject early with the result when encountering an error.
        reject({
          command: [command].concat(args).join(' '),
          errorMessage: error.message,
          exitCode: error.code,
          stderr: firstChildStderr,
          stdout: ''
        });
      });

      firstChild.stderr.on('data', function (data) {
        firstChildStderr += data;
      });

      lastChild = spawn(localOptions.pipedCommand, localOptions.pipedArgs, localOptions);
      monitorStreamErrors(lastChild, command, args, localOptions);
      firstChild.stdout.pipe(lastChild.stdin);
    } else {
      lastChild = spawn(command, args, localOptions);
      monitorStreamErrors(lastChild, command, args, localOptions);
      firstChild = lastChild;
    }

    var stderr = '';
    var stdout = '';
    lastChild.on('close', function (exitCode) {
      resolve({
        exitCode: exitCode,
        stderr: stderr,
        stdout: stdout
      });
    });

    lastChild.on('error', function (error) {
      // Reject early with the result when encountering an error.
      reject({
        command: [command].concat(args).join(' '),
        errorMessage: error.message,
        exitCode: error.code,
        stderr: stderr,
        stdout: stdout
      });
    });

    lastChild.stderr.on('data', function (data) {
      stderr += data;
    });
    lastChild.stdout.on('data', function (data) {
      stdout += data;
    });

    if (typeof localOptions.stdin === 'string') {
      // Note that the Node docs have this scary warning about stdin.end() on
      // http://nodejs.org/api/child_process.html#child_process_child_stdin:
      //
      // "A Writable Stream that represents the child process's stdin. Closing
      // this stream via end() often causes the child process to terminate."
      //
      // In practice, this has not appeared to cause any issues thus far.
      firstChild.stdin.write(localOptions.stdin);
      firstChild.stdin.end();
    }
  };

  function makePromise() {
    if (localOptions.queueName === undefined) {
      return new Promise(executor);
    } else {
      if (!blockingQueues[localOptions.queueName]) {
        blockingQueues[localOptions.queueName] = new PromiseQueue();
      }
      return blockingQueues[localOptions.queueName].submit(executor);
    }
  }

  return createExecEnvironment(localOptions.env || process.env, COMMON_BINARY_PATHS).then(function (val) {
    localOptions.env = val;
    return makePromise();
  }, function (error) {
    localOptions.env = localOptions.env || process.env;
    return makePromise();
  });
}

module.exports = {
  asyncExecute: asyncExecute,
  createArgsForScriptCommand: createArgsForScriptCommand,
  checkOutput: checkOutput,
  safeSpawn: safeSpawn,
  scriptSafeSpawn: scriptSafeSpawn,
  createExecEnvironment: createExecEnvironment,
  COMMON_BINARY_PATHS: COMMON_BINARY_PATHS,
  __test__: {
    DARWIN_PATH_HELPER_REGEXP: DARWIN_PATH_HELPER_REGEXP
  }
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy93MS9fMm1jNm0wNTBxbjIzMm5wc2Y5ejNoZnNoNThfamgvVC90bXBpMzV6akdwdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLWNvbW1vbnMvbGliL3Byb2Nlc3MuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsV0FBVyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQTZFRyxxQkFBcUIscUJBQXBDLFdBQXFDLFdBQW1CLEVBQUUsaUJBQWdDLEVBQW1CO0FBQzNHLE1BQUksT0FBTyxnQkFBTyxXQUFXLENBQUMsQ0FBQzs7QUFFL0IsTUFBSSxPQUFPLENBQUMsSUFBSSxLQUFLLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFO0FBQ3JDLFdBQU8sT0FBTyxDQUFDO0dBQ2hCOztBQUVELFNBQU8sQ0FBQyxJQUFJLEdBQUcsT0FBTyxDQUFDLElBQUksSUFBSSxFQUFFLENBQUM7O0FBRWxDLE1BQUksWUFBWSxHQUFHLElBQUksQ0FBQztBQUN4QixNQUFJO0FBQ0YsZ0JBQVksR0FBRyxNQUFNLGVBQWUsRUFBRSxDQUFDO0dBQ3hDLENBQUMsT0FBTyxLQUFLLEVBQUU7QUFDZCxZQUFRLENBQUMsMkJBQTJCLEVBQUUsS0FBSyxDQUFDLENBQUM7R0FDOUM7Ozs7QUFJRCxNQUFJLFlBQVksRUFBRTtBQUNoQixXQUFPLENBQUMsSUFBSSxHQUFHLFlBQVksQ0FBQztHQUM3QixNQUFNO0FBQ0wsMkJBQXVCLENBQUMsT0FBTyxFQUFFLGlCQUFpQixDQUFDLENBQUM7R0FDckQ7O0FBRUQsU0FBTyxPQUFPLENBQUM7Q0FDaEI7Ozs7OztJQXNCYyxTQUFTLHFCQUF4QixXQUF5QixPQUFlLEVBQXlGO01BQXZGLElBQW9CLHlEQUFHLEVBQUU7TUFBRSxPQUFnQix5REFBRyxFQUFFOztBQUN4RixTQUFPLENBQUMsR0FBRyxHQUFHLE1BQU0scUJBQXFCLENBQUMsT0FBTyxDQUFDLEdBQUcsSUFBSSxPQUFPLENBQUMsR0FBRyxFQUFFLG1C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SyxFQUFJO0FBQ1AsZ0JBQVksQ0FBQyxHQUFHLEdBQUcsWUFBWSxDQUFDLEdBQUcsSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDO0FBQ25ELFdBQU8sV0FBVyxFQUFFLENBQUM7R0FDdEIsQ0FDRixDQUFDO0NBQ0g7O0FBZUQsTUFBTSxDQUFDLE9BQU8sR0FBRztBQUNmLGNBQVksRUFBWixZQUFZO0FBQ1osNEJBQTBCLEVBQTFCLDBCQUEwQjtBQUMxQixhQUFXLEVBQVgsV0FBVztBQUNYLFdBQVMsRUFBVCxTQUFTO0FBQ1QsaUJBQWUsRUFBZixlQUFlO0FBQ2YsdUJBQXFCLEVBQXJCLHFCQUFxQjtBQUNyQixxQkFBbUIsRUFBbkIsbUJBQW1CO0FBQ25CLFVBQVEsRUFBRTtBQUNSLDZCQUF5QixFQUF6Qix5QkFBeUI7R0FDMUI7Q0FDRixDQUFDIiwiZmlsZSI6Ii92YXIvZm9sZGVycy93MS9fMm1jNm0wNTBxbjIzMm5wc2Y5ejNoZnNoNThfamgvVC90bXBpMzV6akdwdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLWNvbW1vbnMvbGliL3Byb2Nlc3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGJhYmVsJztcbi8qIEBmbG93ICovXG5cbi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgbGljZW5zZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluXG4gKiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIge1xuICBleGVjRmlsZSxcbiAgc3Bhd24sXG59ID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIge1Byb21pc2VRdWV1ZX0gPSByZXF1aXJlKCcuL1Byb21pc2VFeGVjdXRvcnMnKTtcblxudmFyIHBsYXRmb3JtUGF0aFByb21pc2U6ID9Qcm9taXNlPHN0cmluZz47XG5cbnZhciBibG9ja2luZ1F1ZXVlcyA9IHt9O1xudmFyIENPTU1PTl9CSU5BUllfUEFUSFMgPSBbJy91c3IvYmluJywgJy9iaW4nLCAnL3Vzci9zYmluJywgJy9zYmluJywgJy91c3IvbG9jYWwvYmluJ107XG5cbi8qIENhcHR1cmVzIHRoZSB2YWx1ZSBvZiB0aGUgUEFUSCBlbnYgdmFyaWFibGUgcmV0dXJuZWQgYnkgRGFyd2luJ3MgKE9TIFgpIGBwYXRoX2hlbHBlcmAgdXRpbGl0eS5cbiAqIGBwYXRoX2hlbHBlciAtc2AncyByZXR1cm4gdmFsdWUgbG9va3MgbGlrZSB0aGlzOlxuICpcbiAqICAgICBQQVRIPVwiL3Vzci9iaW5cIjsgZXhwb3J0IFBBVEg7XG4gKi9cbnZhciBEQVJXSU5fUEFUSF9IRUxQRVJfUkVHRVhQID0gL1BBVEg9XFxcIihbXlxcXCJdKylcXFwiLztcblxudmFyIFNUUkVBTV9OQU1FUyA9IFsnc3RkaW4nLCAnc3Rkb3V0JywgJ3N0ZGVyciddO1xuXG5mdW5jdGlvbiBnZXRQbGF0Zm9ybVBhdGgoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgaWYgKHBsYXRmb3JtUGF0aFByb21pc2UpIHtcbiAgICAvLyBQYXRoIGlzIGJlaW5nIGZldGNoZWQsIGF3YWl0IHRoZSBQcm9taXNlIHRoYXQncyBpbiBmbGlnaHQuXG4gICAgcmV0dXJuIHBsYXRmb3JtUGF0aFByb21pc2U7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2RhcndpbicpIHtcbiAgICAvLyBPUyBYIGFwcHMgZG9uJ3QgaW5oZXJpdCBQQVRIIHdoZW4gbm90IGxhdW5jaGVkIGZyb20gdGhlIENMSSwgc28gcmVjb25zdHJ1Y3QgaXQuIFRoaXMgaXMgYVxuICAgIC8vIGJ1ZywgZmlsZWQgYWdhaW5zdCBBdG9tIExpbnRlciBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vQXRvbUxpbnRlci9MaW50ZXIvaXNzdWVzLzE1MFxuICAgIC8vIFRPRE8oamppYWEpOiByZW1vdmUgdGhpcyBoYWNrIHdoZW4gdGhlIEF0b20gaXNzdWUgaXMgY2xvc2VkXG4gICAgcGxhdGZvcm1QYXRoUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGV4ZWNGaWxlKCcvdXNyL2xpYmV4ZWMvcGF0aF9oZWxwZXInLCBbJy1zJ10sIChlcnJvciwgc3Rkb3V0LCBzdGRlcnIpID0+IHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbWF0Y2ggPSBzdGRvdXQubWF0Y2goREFSV0lOX1BBVEhfSEVMUEVSX1JFR0VYUCk7XG4gICAgICAgICAgcmVzb2x2ZSgobWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMSkgPyBtYXRjaFsxXSA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcGxhdGZvcm1QYXRoUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgnJyk7XG4gIH1cblxuICByZXR1cm4gcGxhdGZvcm1QYXRoUHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ29tbW9uQmluYXJ5UGF0aHMoZW52OiBPYmplY3QsIGNvbW1vbkJpbmFyeVBhdGhzOiBBcnJheTxzdHJpbmc+KTogdm9pZCB7XG4gIGNvbW1vbkJpbmFyeVBhdGhzLmZvckVhY2goKGJpbmFyeVBhdGgpID0+IHtcbiAgICBpZiAoZW52LlBBVEguaW5kZXhPZihiaW5hcnlQYXRoKSA9PT0gLTEpIHtcbiAgICAgIGVudi5QQVRIICs9IHBhdGguZGVsaW1pdGVyICsgYmluYXJ5UGF0aDtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFNpbmNlIE9TIFggYXBwcyBkb24ndCBpbmhlcml0IFBBVEggd2hlbiBub3QgbGF1bmNoZWQgZnJvbSB0aGUgQ0xJLCB0aGlzIGZ1bmN0aW9uIGNyZWF0ZXMgYSBuZXdcbiAqIGVudmlyb25tZW50IG9iamVjdCBnaXZlbiB0aGUgb3JpZ2luYWwgZW52aXJvbm1lbnQgYnkgbW9kaWZ5aW5nIHRoZSBlbnYuUEFUSCB1c2luZyBmb2xsb3dpbmdcbiAqIGxvZ2ljOlxuICogIDEpIElmIG9yaWdpbmFsRW52LlBBVEggZG9lc24ndCBlcXVhbCB0byBwcm9jZXNzLmVudi5QQVRILCB3aGljaCBtZWFucyB0aGUgUEFUSCBoYXMgYmVlblxuICogICAgbW9kaWZpZWQsIHdlIHNob3VsZG4ndCBkbyBhbnl0aGluZy5cbiAqICAxKSBJZiB3ZSBhcmUgcnVubmluZyBpbiBPUyBYLCB1c2UgYC91c3IvbGliZXhlYy9wYXRoX2hlbHBlciAtc2AgdG8gZ2V0IHRoZSBjb3JyZWN0IFBBVEggYW5kXG4gKiAgICBSRVBMQUNFIHRoZSBQQVRILlxuICogIDIpIElmIHN0ZXAgMSBmYWlsZWQgb3Igd2UgYXJlIG5vdCBydW5uaW5nIGluIE9TIFgsIEFQUEVORCBjb21tb25CaW5hcnlQYXRocyB0byBjdXJyZW50IFBBVEguXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUV4ZWNFbnZpcm9ubWVudChvcmlnaW5hbEVudjogT2JqZWN0LCBjb21tb25CaW5hcnlQYXRoczogQXJyYXk8c3RyaW5nPik6IFByb21pc2U8T2JqZWN0PiB7XG4gIHZhciBleGVjRW52ID0gey4uLm9yaWdpbmFsRW52fTtcblxuICBpZiAoZXhlY0Vudi5QQVRIICE9PSBwcm9jZXNzLmVudi5QQVRIKSB7XG4gICAgcmV0dXJuIGV4ZWNFbnY7XG4gIH1cblxuICBleGVjRW52LlBBVEggPSBleGVjRW52LlBBVEggfHwgJyc7XG5cbiAgdmFyIHBsYXRmb3JtUGF0aCA9IG51bGw7XG4gIHRyeSB7XG4gICAgcGxhdGZvcm1QYXRoID0gYXdhaXQgZ2V0UGxhdGZvcm1QYXRoKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgbG9nRXJyb3IoJ0ZhaWxlZCB0byBnZXRQbGF0Zm9ybVBhdGgnLCBlcnJvcik7XG4gIH1cblxuICAvLyBJZiB0aGUgcGxhdGZvcm0gcmV0dXJucyBhIG5vbi1lbXB0eSBQQVRILCB1c2UgaXQuIE90aGVyd2lzZSB1c2UgdGhlIGRlZmF1bHQgc2V0IG9mIGNvbW1vblxuICAvLyBiaW5hcnkgcGF0aHMuXG4gIGlmIChwbGF0Zm9ybVBhdGgpIHtcbiAgICBleGVjRW52LlBBVEggPSBwbGF0Zm9ybVBhdGg7XG4gIH0gZWxzZSB7XG4gICAgYXBwZW5kQ29tbW9uQmluYXJ5UGF0aHMoZXhlY0VudiwgY29tbW9uQmluYXJ5UGF0aHMpO1xuICB9XG5cbiAgcmV0dXJuIGV4ZWNFbnY7XG59XG5cbmZ1bmN0aW9uIGxvZ0Vycm9yKC4uLmFyZ3MpIHtcbiAgLy8gQ2FuJ3QgdXNlIG51Y2xpZGUtbG9nZ2luZyBoZXJlIHRvIG5vdCBjYXVzZSBjeWNsZSBkZXBlbmRlbmN5LlxuICAvKmVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUqL1xuICBjb25zb2xlLmVycm9yKC4uLmFyZ3MpO1xuICAvKmVzbGludC1lbmFibGUgbm8tY29uc29sZSovXG59XG5cbmZ1bmN0aW9uIG1vbml0b3JTdHJlYW1FcnJvcnMocHJvY2VzczogY2hpbGRfcHJvY2VzcyRDaGlsZFByb2Nlc3MsIGNvbW1hbmQsIGFyZ3MsIG9wdGlvbnMpOiB2b2lkIHtcbiAgU1RSRUFNX05BTUVTLmZvckVhY2goc3RyZWFtTmFtZSA9PiB7XG4gICAgLy8gJEZsb3dJc3N1ZVxuICAgIHByb2Nlc3Nbc3RyZWFtTmFtZV0ub24oJ2Vycm9yJywgZXJyb3IgPT4ge1xuICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIHdpdGhvdXQgdGhlIGZ1bGwgZXhlY3V0aW9uIG9mIHRoZSBjb21tYW5kIHRvIGZhaWwsIGJ1dCB3ZSB3YW50IHRvIGxlYXJuIGFib3V0IGl0LlxuICAgICAgbG9nRXJyb3IoJ3N0cmVhbSBlcnJvciB3aXRoIGNvbW1hbmQ6JywgY29tbWFuZCwgYXJncywgb3B0aW9ucywgJ2Vycm9yOicsIGVycm9yKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKiBCYXNpY2FsbHkgbGlrZSBzcGF3biwgZXhjZXB0IGl0IGhhbmRsZXMgYW5kIGxvZ3MgZXJyb3JzIGluc3RlYWQgb2YgY3Jhc2hpbmdcbiAgKiB0aGUgcHJvY2Vzcy4gVGhpcyBpcyBtdWNoIGxvd2VyLWxldmVsIHRoYW4gYXN5bmNFeGVjdXRlLiBVbmxlc3MgeW91IGhhdmUgYVxuICAqIHNwZWNpZmljIHJlYXNvbiB5b3Ugc2hvdWxkIHVzZSBhc3luY0V4ZWN1dGUgaW5zdGVhZC4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNhZmVTcGF3bihjb21tYW5kOiBzdHJpbmcsIGFyZ3M/OiBBcnJheTxzdHJpbmc+ID0gW10sIG9wdGlvbnM/OiBPYmplY3QgPSB7fSk6IFByb21pc2U8Y2hpbGRfcHJvY2VzcyRDaGlsZFByb2Nlc3M+IHtcbiAgb3B0aW9ucy5lbnYgPSBhd2FpdCBjcmVhdGVFeGVjRW52aXJvbm1lbnQob3B0aW9ucy5lbnYgfHwgcHJvY2Vzcy5lbnYsIENPTU1PTl9CSU5BUllfUEFUSFMpO1xuICB2YXIgY2hpbGQgPSBzcGF3bihjb21tYW5kLCBhcmdzLCBvcHRpb25zKTtcbiAgbW9uaXRvclN0cmVhbUVycm9ycyhjaGlsZCwgY29tbWFuZCwgYXJncywgb3B0aW9ucyk7XG4gIGNoaWxkLm9uKCdlcnJvcicsIGVycm9yID0+IHtcbiAgICBsb2dFcnJvcignZXJyb3Igd2l0aCBjb21tYW5kOicsIGNvbW1hbmQsIGFyZ3MsIG9wdGlvbnMsICdlcnJvcjonLCBlcnJvcik7XG4gIH0pO1xuICByZXR1cm4gY2hpbGQ7XG59XG5cbnZhciBpc09zWCA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nO1xuXG4vKipcbiAqIFRha2VzIHRoZSBjb21tYW5kIGFuZCBhcmdzIHRoYXQgeW91IHdvdWxkIG5vcm1hbGx5IHBhc3MgdG8gYHNwYXduKClgIGFuZCByZXR1cm5zIGBuZXdBcmdzYCBzdWNoXG4gKiB0aGF0IHlvdSBzaG91bGQgY2FsbCBpdCB3aXRoIGBzcGF3bignc2NyaXB0JywgbmV3QXJncylgIHRvIHJ1biB0aGUgb3JpZ2luYWwgY29tbWFuZC9hcmdzIHBhaXJcbiAqIHVuZGVyIGBzY3JpcHRgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVBcmdzRm9yU2NyaXB0Q29tbWFuZChjb21tYW5kOiBzdHJpbmcsIGFyZ3M/OiBBcnJheTxzdHJpbmc+ID0gW10pOiBBcnJheTxzdHJpbmc+IHtcbiAgaWYgKGlzT3NYKSB7XG4gICAgLy8gT24gT1MgWCwgc2NyaXB0IHRha2VzIHRoZSBwcm9ncmFtIHRvIHJ1biBhbmQgaXRzIGFyZ3VtZW50cyBhcyB2YXJhcmdzIGF0IHRoZSBlbmQuXG4gICAgcmV0dXJuIFsnLXEnLCAnL2Rldi9udWxsJywgY29tbWFuZF0uY29uY2F0KGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIC8vIE9uIExpbnV4LCBzY3JpcHQgdGFrZXMgdGhlIGNvbW1hbmQgdG8gcnVuIGFzIHRoZSAtYyBwYXJhbWV0ZXIuXG4gICAgLy8gVE9ETzogU2hlbGwgZXNjYXBlIGV2ZXJ5IGVsZW1lbnQgaW4gYWxsQXJncy5cbiAgICB2YXIgYWxsQXJncyA9IFtjb21tYW5kXS5jb25jYXQoYXJncyk7XG4gICAgdmFyIGNvbW1hbmRBc0l0c093bkFyZyA9IGFsbEFyZ3Muam9pbignICcpO1xuICAgIHJldHVybiBbJy1xJywgJy9kZXYvbnVsbCcsICctYycsIGNvbW1hbmRBc0l0c093bkFyZ107XG4gIH1cbn1cblxuLyoqXG4gKiBCYXNpY2FsbHkgbGlrZSBzYWZlU3Bhd24sIGJ1dCBydW5zIHRoZSBjb21tYW5kIHdpdGggdGhlIGBzY3JpcHRgIGNvbW1hbmQuXG4gKiBgc2NyaXB0YCBlbnN1cmVzIHRlcm1pbmFsLWxpa2UgZW52aXJvbm1lbnQgYW5kIGNvbW1hbmRzIHdlIHJ1biBnaXZlIGNvbG9yZWQgb3V0cHV0LlxuICovXG5mdW5jdGlvbiBzY3JpcHRTYWZlU3Bhd24oXG4gIGNvbW1hbmQ6IHN0cmluZyxcbiAgYXJncz86IEFycmF5PHN0cmluZz4gPSBbXSxcbiAgb3B0aW9ucz86IE9iamVjdCA9IHt9LFxuKTogUHJvbWlzZTxjaGlsZF9wcm9jZXNzJENoaWxkUHJvY2Vzcz4ge1xuICB2YXIgbmV3QXJncyA9IGNyZWF0ZUFyZ3NGb3JTY3JpcHRDb21tYW5kKGNvbW1hbmQsIGFyZ3MpO1xuICByZXR1cm4gc2FmZVNwYXduKCdzY3JpcHQnLCBuZXdBcmdzLCBvcHRpb25zKTtcbn1cblxudHlwZSBwcm9jZXNzJGFzeW5jRXhlY3V0ZVJldCA9IHtcbiAgY29tbWFuZD86IHN0cmluZztcbiAgZXJyb3JNZXNzYWdlPzogc3RyaW5nO1xuICBleGl0Q29kZTogbnVtYmVyO1xuICBzdGRlcnI6IHN0cmluZztcbiAgc3Rkb3V0OiBzdHJpbmc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHJlc3VsdCBvZiBleGVjdXRpbmcgYSBwcm9jZXNzLlxuICpcbiAqIEBwYXJhbSBjb21tYW5kIFRoZSBjb21tYW5kIHRvIGV4ZWN1dGUuXG4gKiBAcGFyYW0gYXJncyBUaGUgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIGNvbW1hbmQuXG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGZvciBjaGFuZ2luZyBob3cgdG8gcnVuIHRoZSBjb21tYW5kLlxuICogICAgIFNlZSBoZXJlOiBodHRwOi8vbm9kZWpzLm9yZy9hcGkvY2hpbGRfcHJvY2Vzcy5odG1sXG4gKiAgICAgVGhlIGFkZGl0aW9uYWwgb3B0aW9ucyB3ZSBwcm92aWRlOlxuICogICAgICAgcXVldWVOYW1lIHN0cmluZyBUaGUgcXVldWUgb24gd2hpY2ggdG8gYmxvY2sgZGVwZW5kZW50IGNhbGxzLlxuICogICAgICAgc3RkaW4gc3RyaW5nIFRoZSBjb250ZW50cyB0byB3cml0ZSB0byBzdGRpbi5cbiAqICAgICAgIHBpcGVkQ29tbWFuZCBzdHJpbmcgYSBjb21tYW5kIHRvIHBpcGUgdGhlIG91dHB1dCBvZiBjb21tYW5kIHRocm91Z2guXG4gKiAgICAgICBwaXBlZEFyZ3MgYXJyYXkgb2Ygc3RyaW5ncyBhcyBhcmd1bWVudHMuXG4gKiBAcmV0dXJuIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBvYmplY3Qgd2l0aCB0aGUgcHJvcGVydGllczpcbiAqICAgICBzdGRvdXQgc3RyaW5nIFRoZSBjb250ZW50cyBvZiB0aGUgcHJvY2VzcydzIG91dHB1dCBzdHJlYW0uXG4gKiAgICAgc3RkZXJyIHN0cmluZyBUaGUgY29udGVudHMgb2YgdGhlIHByb2Nlc3MncyBlcnJvciBzdHJlYW0uXG4gKiAgICAgZXhpdENvZGUgbnVtYmVyIFRoZSBleGl0IGNvZGUgcmV0dXJuZWQgYnkgdGhlIHByb2Nlc3MuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT3V0cHV0KFxuICAgIGNvbW1hbmQ6IHN0cmluZyxcbiAgICBhcmdzOiBBcnJheTxzdHJpbmc+LFxuICAgIG9wdGlvbnM6ID9PYmplY3QgPSB7fSk6IFByb21pc2U8cHJvY2VzcyRhc3luY0V4ZWN1dGVSZXQ+IHtcbiAgLy8gQ2xvbmUgcGFzc2VkIGluIG9wdGlvbnMgc28gdGhpcyBmdW5jdGlvbiBkb2Vzbid0IG1vZGlmeSBhbiBvYmplY3QgaXQgZG9lc24ndCBvd24uXG4gIHZhciBsb2NhbE9wdGlvbnMgPSB7Li4ub3B0aW9uc307XG5cbiAgdmFyIGV4ZWN1dG9yID0gKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHZhciBmaXJzdENoaWxkO1xuICAgIHZhciBsYXN0Q2hpbGQ7XG5cbiAgICB2YXIgZmlyc3RDaGlsZFN0ZGVycjtcbiAgICBpZiAobG9jYWxPcHRpb25zLnBpcGVkQ29tbWFuZCkge1xuICAgICAgLy8gSWYgYSBzZWNvbmQgY29tbWFuZCBpcyBnaXZlbiwgcGlwZSBzdGRvdXQgb2YgZmlyc3QgdG8gc3RkaW4gb2Ygc2Vjb25kLiBTdHJpbmcgb3V0cHV0XG4gICAgICAvLyByZXR1cm5lZCBpbiB0aGlzIGZ1bmN0aW9uJ3MgUHJvbWlzZSB3aWxsIGJlIHN0ZGVyci9zdGRvdXQgb2YgdGhlIHNlY29uZCBjb21tYW5kLlxuICAgICAgZmlyc3RDaGlsZCA9IHNwYXduKGNvbW1hbmQsIGFyZ3MsIGxvY2FsT3B0aW9ucyk7XG4gICAgICBtb25pdG9yU3RyZWFtRXJyb3JzKGZpcnN0Q2hpbGQsIGNvbW1hbmQsIGFyZ3MsIGxvY2FsT3B0aW9ucyk7XG4gICAgICBmaXJzdENoaWxkU3RkZXJyID0gJyc7XG5cbiAgICAgIGZpcnN0Q2hpbGQub24oJ2Vycm9yJywgZXJyb3IgPT4ge1xuICAgICAgICAvLyBSZWplY3QgZWFybHkgd2l0aCB0aGUgcmVzdWx0IHdoZW4gZW5jb3VudGVyaW5nIGFuIGVycm9yLlxuICAgICAgICByZWplY3Qoe1xuICAgICAgICAgIGNvbW1hbmQ6IFtjb21tYW5kXS5jb25jYXQoYXJncykuam9pbignICcpLFxuICAgICAgICAgIGVycm9yTWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICBleGl0Q29kZTogZXJyb3IuY29kZSxcbiAgICAgICAgICBzdGRlcnI6IGZpcnN0Q2hpbGRTdGRlcnIsXG4gICAgICAgICAgc3Rkb3V0OiAnJyxcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgZmlyc3RDaGlsZC5zdGRlcnIub24oJ2RhdGEnLCBkYXRhID0+IHtcbiAgICAgICAgZmlyc3RDaGlsZFN0ZGVyciArPSBkYXRhO1xuICAgICAgfSk7XG5cbiAgICAgIGxhc3RDaGlsZCA9IHNwYXduKGxvY2FsT3B0aW9ucy5waXBlZENvbW1hbmQsIGxvY2FsT3B0aW9ucy5waXBlZEFyZ3MsIGxvY2FsT3B0aW9ucyk7XG4gICAgICBtb25pdG9yU3RyZWFtRXJyb3JzKGxhc3RDaGlsZCwgY29tbWFuZCwgYXJncywgbG9jYWxPcHRpb25zKTtcbiAgICAgIGZpcnN0Q2hpbGQuc3Rkb3V0LnBpcGUobGFzdENoaWxkLnN0ZGluKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdENoaWxkID0gc3Bhd24oY29tbWFuZCwgYXJncywgbG9jYWxPcHRpb25zKTtcbiAgICAgIG1vbml0b3JTdHJlYW1FcnJvcnMobGFzdENoaWxkLCBjb21tYW5kLCBhcmdzLCBsb2NhbE9wdGlvbnMpO1xuICAgICAgZmlyc3RDaGlsZCA9IGxhc3RDaGlsZDtcbiAgICB9XG5cbiAgICB2YXIgc3RkZXJyID0gJyc7XG4gICAgdmFyIHN0ZG91dCA9ICcnO1xuICAgIGxhc3RDaGlsZC5vbignY2xvc2UnLCBleGl0Q29kZSA9PiB7XG4gICAgICByZXNvbHZlKHtcbiAgICAgICAgZXhpdENvZGUsXG4gICAgICAgIHN0ZGVycixcbiAgICAgICAgc3Rkb3V0LFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBsYXN0Q2hpbGQub24oJ2Vycm9yJywgZXJyb3IgPT4ge1xuICAgICAgLy8gUmVqZWN0IGVhcmx5IHdpdGggdGhlIHJlc3VsdCB3aGVuIGVuY291bnRlcmluZyBhbiBlcnJvci5cbiAgICAgIHJlamVjdCh7XG4gICAgICAgIGNvbW1hbmQ6IFtjb21tYW5kXS5jb25jYXQoYXJncykuam9pbignICcpLFxuICAgICAgICBlcnJvck1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgIGV4aXRDb2RlOiBlcnJvci5jb2RlLFxuICAgICAgICBzdGRlcnIsXG4gICAgICAgIHN0ZG91dCxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgbGFzdENoaWxkLnN0ZGVyci5vbignZGF0YScsIGRhdGEgPT4ge1xuICAgICAgc3RkZXJyICs9IGRhdGE7XG4gICAgfSk7XG4gICAgbGFzdENoaWxkLnN0ZG91dC5vbignZGF0YScsIGRhdGEgPT4ge1xuICAgICAgc3Rkb3V0ICs9IGRhdGE7XG4gICAgfSk7XG5cbiAgICBpZiAodHlwZW9mIGxvY2FsT3B0aW9ucy5zdGRpbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIE5vdGUgdGhhdCB0aGUgTm9kZSBkb2NzIGhhdmUgdGhpcyBzY2FyeSB3YXJuaW5nIGFib3V0IHN0ZGluLmVuZCgpIG9uXG4gICAgICAvLyBodHRwOi8vbm9kZWpzLm9yZy9hcGkvY2hpbGRfcHJvY2Vzcy5odG1sI2NoaWxkX3Byb2Nlc3NfY2hpbGRfc3RkaW46XG4gICAgICAvL1xuICAgICAgLy8gXCJBIFdyaXRhYmxlIFN0cmVhbSB0aGF0IHJlcHJlc2VudHMgdGhlIGNoaWxkIHByb2Nlc3MncyBzdGRpbi4gQ2xvc2luZ1xuICAgICAgLy8gdGhpcyBzdHJlYW0gdmlhIGVuZCgpIG9mdGVuIGNhdXNlcyB0aGUgY2hpbGQgcHJvY2VzcyB0byB0ZXJtaW5hdGUuXCJcbiAgICAgIC8vXG4gICAgICAvLyBJbiBwcmFjdGljZSwgdGhpcyBoYXMgbm90IGFwcGVhcmVkIHRvIGNhdXNlIGFueSBpc3N1ZXMgdGh1cyBmYXIuXG4gICAgICBmaXJzdENoaWxkLnN0ZGluLndyaXRlKGxvY2FsT3B0aW9ucy5zdGRpbik7XG4gICAgICBmaXJzdENoaWxkLnN0ZGluLmVuZCgpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlUHJvbWlzZSgpOiBQcm9taXNlPHByb2Nlc3MkYXN5bmNFeGVjdXRlUmV0PiB7XG4gICAgaWYgKGxvY2FsT3B0aW9ucy5xdWV1ZU5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGV4ZWN1dG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFibG9ja2luZ1F1ZXVlc1tsb2NhbE9wdGlvbnMucXVldWVOYW1lXSkge1xuICAgICAgICBibG9ja2luZ1F1ZXVlc1tsb2NhbE9wdGlvbnMucXVldWVOYW1lXSA9IG5ldyBQcm9taXNlUXVldWUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBibG9ja2luZ1F1ZXVlc1tsb2NhbE9wdGlvbnMucXVldWVOYW1lXS5zdWJtaXQoZXhlY3V0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjcmVhdGVFeGVjRW52aXJvbm1lbnQobG9jYWxPcHRpb25zLmVudiB8fCBwcm9jZXNzLmVudiwgQ09NTU9OX0JJTkFSWV9QQVRIUykudGhlbihcbiAgICB2YWwgPT4ge1xuICAgICAgbG9jYWxPcHRpb25zLmVudiA9IHZhbDtcbiAgICAgIHJldHVybiBtYWtlUHJvbWlzZSgpO1xuICAgIH0sXG4gICAgZXJyb3IgPT4ge1xuICAgICAgbG9jYWxPcHRpb25zLmVudiA9IGxvY2FsT3B0aW9ucy5lbnYgfHwgcHJvY2Vzcy5lbnY7XG4gICAgICByZXR1cm4gbWFrZVByb21pc2UoKTtcbiAgICB9XG4gICk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGFzeW5jRXhlY3V0ZShcbiAgICBjb21tYW5kOiBzdHJpbmcsXG4gICAgYXJnczogQXJyYXk8c3RyaW5nPixcbiAgICBvcHRpb25zOiA/T2JqZWN0ID0ge30pOiBQcm9taXNlPHByb2Nlc3MkYXN5bmNFeGVjdXRlUmV0PiB7XG4gIHZhciByZXN1bHQgPSBhd2FpdCBjaGVja091dHB1dChjb21tYW5kLCBhcmdzLCBvcHRpb25zKTtcbiAgaWYgKHJlc3VsdC5leGl0Q29kZSAhPT0gMCkge1xuICAgIC8vIFRPRE8odDgyMTU1MzkpOiBBZGQgcHJvcGVydGllcyBzdWNoIGFzIFwibWVzc2FnZVwiIGFuZCBcInRvU3RyaW5nKClcIiBzbyB0aGF0IGlmIHRoZSBjYWxsZXJcbiAgICAvLyBjYXRjaGVzIHRoaXMgYXMgaWYgaXQgd2VyZSBhbiBlcnJvciwgaXQgd2lsbCBwcmludCBuaWNlbHkgcmF0aGVyIHRoYW4gXCJbb2JqZWN0IE9iamVjdF1cIi5cbiAgICB0aHJvdyByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFzeW5jRXhlY3V0ZSxcbiAgY3JlYXRlQXJnc0ZvclNjcmlwdENvbW1hbmQsXG4gIGNoZWNrT3V0cHV0LFxuICBzYWZlU3Bhd24sXG4gIHNjcmlwdFNhZmVTcGF3bixcbiAgY3JlYXRlRXhlY0Vudmlyb25tZW50LFxuICBDT01NT05fQklOQVJZX1BBVEhTLFxuICBfX3Rlc3RfXzoge1xuICAgIERBUldJTl9QQVRIX0hFTFBFUl9SRUdFWFAsXG4gIH0sXG59O1xuIl19
